xmq is an Erlang library that provides cross message system utilities.

Features:

- AMQP to 0MQ bridge

* xmq_az_bridge

The (a)MQP to (z)eroMQ bridge lets 0MQ clients participate in an AMQP routing
scheme.

It works like this:

- Bridge connects to AMQP broker and binds a number of topics to a queue
- Bridge provides a ROUTER 0MQ socket
  - Clients routinely publish expirable routes
  - Clients send messages destined to AMQP
  - Clients receive messages routed by bridge from AMQP
- Bridge routinely unbinds topics as routes expire

** Client Operations

The bridge will support these client operations:

| bind | Specify client bindings |
| send | Send an AMQP message    |

The bind message will be a ZMQ multi-part message:

  [<<"bind">>, DirectBinding | TopicBindings]

For example:

  [<<"bind">>, <<"my-direct-queue">>, <<"test.#">>]

The send message:

  [<<"send">>, Exchange, Key, binary(#amqp_msg{})]

NOTE: The message here is an binary encoded amqp_msg Erlang record. This
ties clients to Erlang for the time being. If we need to support other clients,
we'd need to support an independent encoding scheme such as JSON, msgpack, etc.

** Bridge Setup Example

#+begin_src erlang
  Options = [{direct_binding, {<<"amq.direct">>, <<"my-queue">>}},
             {topic_bindings, {<<"amq.topic">>, [<<"test.#">>]}},
             {amqp_host, "localhost"},
             {amqp_creds, {<<"guest">>, <<"guest">>}},
             {router_endpoint, "tcp://*:5555"}],
  xmq_az_bridge:start_link(Bindings, Options)
#+end_src

This bridge will connect to the local AMQP broker using the specified user name
and password.

It will bind a router socket to the local interface at port 5555. 0MQ clients
can use this to routinely publish their bindings, send messages, and receive
messages by way of the AMQP broker according to their bindings.

* Utilities

** Routing Tables

The module xmq_routes provides these functions:

| add_direct(Key, Dest, Expires) | Adds a direct route    |
| get_direct(Key)                | Gets a direct consumer |
| add_topic(Key, Dest, Expires)  | Adds a topic route     |
| get_topic(Key)                 | Gets topic consumers   |

Routes expire if they're not routinely updated. Clients are expected to update
their routing information in regular periods to ensure they receive
messages. If a client doesn't update its routes, the routes will eventually
expire.

*** Topics Search

Is a pain! To accommodate efficient lookup of patterns like "a.#.c" is a lot of
effort for very little payoff.

Here's a sketch of the problem.

Consider a set of bindings B1 = B5:

B1: a.#
B2: a.b
B3: a.b.#
B4: a.c
B5: a.#.c

And a routing key:

Msg:  a.b.c.d

The key must be divided into its parts and evaluated against the bindings.

| Part | Explicit       | Wildcard | Acc Wildcard  | Result         |
| a    | B1 B2 B3 B4 B5 |          |               | B1 B2 B3 B4 B5 |
| b    | B2 B3          | B1 B5    | B1 B5         | B1 B2 B3 B5    |
| c    | B5             | B3       | B1 B3         | B1 B3 B5       |
| d    |                |          | B1 B3         | B1 B3          |

Rules:

- Result when no Result0 = union(Explicit, AccWildcard)
- Result = intersection(union(Explicit, AccWildcard), Result0)
- AccWildcard = union(Wildcard, AccWildcard0) - Explicit
* To Do

** Complete xmq_zmq_client

*** Direct bindings

Support sending diretly to the client. Will be used in collecting replies.

Is this something we need to specify?

*** RPC facility

Send a message with the expectation that we'll receive one or more replies or a
time-to-live.

Something like this:

#+begin_src erlang
  xmq_az_client:call(C, <<"amq.topic">>, <<"test.echo">>, <<"hello">>,
                     [{timeout, 5000}])
#+end_src

Would send to the topic exchange with key "test.echo" and wait 5 seconds for
responses.

If the expectation is that one response will be provided:

#+begin_src erlang
  xmq_az_client:call(C, <<"amq.topic">>, <<"test.echo">>, <<"hello">>,
                     [{replies, 1}, {timeout, 5000})
#+end_src

The default "wait for" options would be:

  [{replies, infinity}, {timeout, 5000}]
